DeepLearning.AI Lesson 3 Reimagined: Writing UI for Auto Blog Creation
In this blog post, I want to reflect on "Lesson 3: Agent Reflection Framework and Auto Blog Post Creation" from DeepLearning.AI and explore an evolution of the idea. Originally, the aim was to fully automate blog creation, having an agent write entire posts. However, after some soul-searching, I've come to realize that the goal of full automation might still be a bit far off. So, what's the best next thing? A semi-automatic approach!
I introduce to you a UI for an auto blog writer using wxPython. While the agent won't be complete blogs, this tool will give us a streamlined way to create blogs efficiently, guiding the process and helping us design structure of blog and shape content more quickly and accurately.
Why wxPython?
We will be using wxPython because of its ease of use, rich features, and the wealth of support provided by various AI coding helpers like ChatGPT and others. wxPython makes building user interfaces straightforward, even for those who might not be seasoned UI developers. Its simple syntax and great documentation allow for rapid development of desktop applications. Plus, with AI coding assistants, learning and implementing it is a breeze.
In the rest of this blog, I'll guide you through building this UI for our semi-automatic blog creation tool, starting from the code, which we'll discuss below.
Getting Started with the Code
In this section, we'll explore the code attached to the project to add new sections to our blog writing UI. This application will allow users to create and edit blog posts easily by providing a user-friendly interface for writing and organizing content.
The provided code focuses on creating a structure where each blog section is treated as an individual entity. Users can add, edit, or remove sections of the blog dynamically, and the UI makes this interaction as intuitive as possible.
Here's a snippet of the code that powers this UI:
# Import necessary libraries
import wx

class BlogSection:
    def __init__(self, title, content):
        self.title = title
        self.content = content

class BlogEditorFrame(wx.Frame):
    def __init__(self, parent, title):
        super().__init__(parent, title=title, size=(600, 400))
        
        # Initialize the main panel
        self.panel = wx.Panel(self)
        self.sizer = wx.BoxSizer(wx.VERTICAL)
        
        # Add title input
        self.title_label = wx.StaticText(self.panel, label="Blog Title")
        self.sizer.Add(self.title_label, flag=wx.LEFT | wx.TOP, border=10)
        self.title_input = wx.TextCtrl(self.panel)
        self.sizer.Add(self.title_input, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, border=10)
        
        # Add content input
        self.content_label = wx.StaticText(self.panel, label="Blog Content")
        self.sizer.Add(self.content_label, flag=wx.LEFT | wx.TOP, border=10)
        self.content_input = wx.TextCtrl(self.panel, style=wx.TE_MULTILINE)
        self.sizer.Add(self.content_input, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, border=10)
        
        # Add button to save blog post
        self.save_button = wx.Button(self.panel, label="Save Blog Post")
        self.sizer.Add(self.save_button, flag=wx.ALIGN_CENTER | wx.TOP | wx.BOTTOM, border=10)
        
        # Event binding for button click
        self.save_button.Bind(wx.EVT_BUTTON, self.on_save)
        
        # Set sizer and show the panel
        self.panel.SetSizerAndFit(self.sizer)
        self.Show()

    def on_save(self, event):
        title = self.title_input.GetValue()
        content = self.content_input.GetValue()
        
        if title and content:
            # You can save or process the title and content here
            blog_section = BlogSection(title, content)
            wx.MessageBox(f"Blog Section '{blog_section.title}' saved!", "Success")
        else:
            wx.MessageBox("Please provide both title and content.", "Error")

# Main application loop
app = wx.App(False)
frame = BlogEditorFrame(None, title="Auto Blog Writer UI")
app.MainLoop()
Breaking Down the Code
Class Definition: We start by defining the BlogSection class, which represents a section of the blog. Each section contains a title and content, which are captured from the UI.
BlogEditorFrame Class: This is the main frame that contains our UI components. It inherits from wx.Frame and defines various elements like text input for the blog title, multi-line text input for blog content, and a button to save the blog post.
Save Functionality: When the "Save Blog Post" button is clicked, the on_save function is triggered. It collects the title and content from the text inputs and, if both are provided, saves them as a new blog section.

ExpolePanel: A Crucial UI Component
In our auto blog writer UI, the ExpolePanel is a key part of the application's interface. The panel is responsible for organizing and structuring the UI elements, ensuring everything is neatly arranged and responsive to user interactions. It serves as the foundation for adding and managing different sections of the blog, including the input fields for titles, content, and action buttons.
Here's a snippet from the ExpolePanel implementation:
import wx

class ExpolePanel(wx.Panel):
    def __init__(self, parent):
        super().__init__(parent)

        # Set up a vertical layout to structure blog sections
        self.sizer = wx.BoxSizer(wx.VERTICAL)

        # Label for section title
        self.section_label = wx.StaticText(self, label="Blog Section Title:")
        self.sizer.Add(self.section_label, flag=wx.ALL, border=5)

        # Input field for the section title
        self.section_input = wx.TextCtrl(self)
        self.sizer.Add(self.section_input, flag=wx.EXPAND | wx.ALL, border=5)

        # Set the panel sizer to arrange the components
        self.SetSizer(self.sizer)
DesignPanel: The Heart of Blog Section Management
In our auto blog writer UI, the DesignPanel serves as the central hub for managing blog sections. This panel is where users can create, edit, and organize their blog sections effortlessly. It provides a structured interface to handle various elements like section titles, content, and other interactive components.
The DesignPanel brings together multiple elements and offers an intuitive way to control the flow and structure of the blog post. Here's a look at how the DesignPanel is set up and how it simplifies the blog-writing process:
import wx

class DesignPanel(wx.Panel):
    def __init__(self, parent):
        super().__init__(parent)

        # Initialize layout with a vertical box sizer
        self.sizer = wx.BoxSizer(wx.VERTICAL)

        # Label for blog title
        self.title_label = wx.StaticText(self, label="Blog Title:")
        self.sizer.Add(self.title_label, flag=wx.ALL, border=5)

        # Text input for the blog title
        self.title_input = wx.TextCtrl(self)
        self.sizer.Add(self.title_input, flag=wx.EXPAND | wx.ALL, border=5)

        # Label for blog content
        self.content_label = wx.StaticText(self, label="Blog Content:")
        self.sizer.Add(self.content_label, flag=wx.ALL, border=5)

        # Multi-line text input for blog content
        self.content_input = wx.TextCtrl(self, style=wx.TE_MULTILINE)
        self.sizer.Add(self.content_input, flag=wx.EXPAND | wx.ALL, border=5)

        # Add Save button
        self.save_button = wx.Button(self, label="Save Blog Post")
        self.sizer.Add(self.save_button, flag=wx.ALIGN_CENTER | wx.ALL, border=10)

        # Bind save button to the event handler
        self.save_button.Bind(wx.EVT_BUTTON, self.on_save)

        # Set the sizer to arrange the panel components
        self.SetSizer(self.sizer)

    def on_save(self, event):
        title = self.title_input.GetValue()
        content = self.content_input.GetValue()

        if title and content:
            wx.MessageBox(f"Blog post '{title}' saved!", "Success")
How DesignPanel Simplifies Blog Creation
User-Friendly Layout: The vertical box sizer (wx.BoxSizer) ensures that all the components-such as the title and content fields-are laid out in a clean, vertical alignment. This organization makes the UI intuitive and easy to use.
Dynamic Interaction: The DesignPanel allows for dynamic interaction with the blog content. Users can input their blog titles and content into dedicated fields, and the interface instantly adapts to the user's input.
Event Handling: With the save button, users can save the blog content they've entered. The event handler function (on_save) ensures that once the content is saved, users are notified with success messages. It also provides an error check if any of the required fields are empty.

PreviewPanel: Visualizing Your Blog in Real-Time
One of the key features of our auto blog writer UI is the ability to preview blog posts before finalizing them. The PreviewPanel is a crucial part of this process. It provides users with a real-time view of how their blog content will look once it's published. The preview feature helps ensure that formatting is correct, content is properly aligned, and the overall presentation is polished.
Let's dive into the PreviewPanel and understand its role and implementation:
import wx

class PreviewPanel(wx.Panel):
    def __init__(self, parent):
        super().__init__(parent)

        # Set up the layout for the preview panel
        self.sizer = wx.BoxSizer(wx.VERTICAL)

        # Label for the preview section
        self.preview_label = wx.StaticText(self, label="Blog Post Preview:")
        self.sizer.Add(self.preview_label, flag=wx.ALL, border=5)

        # Static text control to display the preview content
        self.preview_content = wx.StaticText(self, label="")
        self.sizer.Add(self.preview_content, flag=wx.EXPAND | wx.ALL, border=5)

        # Set the sizer for the panel layout
        self.SetSizer(self.sizer)

    def update_preview(self, title, content):
        """Updates the preview with the provided title and content."""
        preview_text = f"Title: {title}\n\nContent:\n{content}"
        self.preview_content.SetLabel(preview_text)
        self.Layout()
How the PreviewPanel Works
Dynamic Preview: The PreviewPanel updates in real time as the user creates or edits sections of the blog post. The update_preview method is triggered whenever the user inputs new data, displaying both the title and content in a formatted manner.
User Interface Design:The PreviewPanel uses a wx.StaticText widget to display the blog content. This ensures that the text is static (non-editable), giving users a clear view of what the final output will look like.
Real-Time Feedback: As users work on their blog, they can see the immediate impact of their writing decisions. This real-time feedback helps ensure that the content reads well, looks good, and is formatted appropriately before final submission.
Putting It All Together: Using the Blog Writer
Now that we are done building the code and setting up the UI components, it's time to use our newly minted Blog Writer. To demonstrate its full potential, let's rewrite this very blog as we did in "DeepLearning.AI Lesson 3 Revisited: How Agent Reflection Powers Comprehensive Blog Creation"
Configuring Python and Installing Dependencies
Before we dive into starting the Blog Writer, let's ensure we have the necessary libraries installed. Our Blog Writer UI relies on a few essential Python libraries, which we'll install now.
Step 1: Installing Required Libraries
Open your terminal or command prompt and run the following commands to install the necessary libraries:
pip install wxpython pubsub openai
wxPython: This library is used to create the user interface for the Blog Writer.
pubsub: This library is utilized for handling messaging and event-based communication between different parts of the application.
openai: We'll be using the OpenAI API in future updates to assist in content generation.

Step 2: Starting the Blog Writer
Once all the libraries are installed, it's time to run the Blog Writer application. Assuming you have your script ready (for example, blog_writer.py), you can start the application by running:
python blog_writer.py
Step 3: Using the Blog Writer
With the application running, the UI will open, and you'll be able to start creating your blog content! You can:
Auto explore possible blog titles and topics using ChatGPT in ExplorePanel.
Add blog sections using the DesignPanel.
Preview the blog in real-time using the PreviewPanel.
Save and edit blog posts effortlessly.

Now that everything is set up and running, you're ready to use the Blog Writer to streamline your blog creation process.

It Opens to…
Once you run the Blog Writer by executing the python blog_writer.py command, the application opens to a clean and structured interface like the one shown in the image below.
Upon launching, the Blog Writer presents you with two main tabs:
Design: This is where you start organizing your blog sections. It begins with a prompt, "Start with Exploration," guiding you to input your first section of the blog. This is an intuitive starting point for designing the structure of your post.
You can start by exploring your ideas in this section and defining what direction the blog post should take.
A green-highlighted button labeled Exploration suggests a dynamic flow to begin shaping the content, prompting the user to move through the design process seamlessly.

Explore & Preview: On the right-hand side of the window, there are two sub-tabs:
Explore: Here, the text area allows you to start drafting blog content (for example, beginning with DeepLearning.AI as seen in the interface). After entering text, the user can generate titles by clicking the Get Titles button, which provides suggestions for your blog.
Preview: This tab will display a real-time preview of how your blog post looks as you write. It's perfect for ensuring that your formatting and content appear exactly how you want them before finalizing the post.

Exploring the Title Suggestions
Once you input your initial ideas and click the Get Titles button, the OpenAI gpt-4o model provides you with a list of title suggestions based on the content you've entered. The image below shows how the application generates a variety of title ideas:
Click '<<<' to Start the Design Process
After you've generated a list of potential blog titles, the next step is to select the one you want to build your blog around. To begin the design process, simply click on the <<< button next to the title of your choice. As shown in the image below, once you click this button, the title gets transferred to the Design tab, where you can start structuring your blog post.
Populating Topics Using GPT-4
After selecting your blog title and moving into the design phase, the next step is to populate the topics related to your chosen title. In the interface, you'll notice a gray "topics" button located right below each title suggestion. This is where the magic happens!
Choosing a Topic
After generating topics with the help of GPT-4, the next step is to choose a topic to work with. To do this, simply click the <<< button next to the topic of your choice, and it will appear in the Design panel, ready for you to start structuring and expanding on that idea.
As shown in the image below, clicking <<< on the topic "Introduction: The Vision Behind DeepLearning.AI's Community Initiatives" moves the topic to the Design tab:
Populating Sections Using GPT-4o
Once you've selected a topic for your blog, the next step is to break down the topic into sections for a more detailed and structured post. To do this, simply click the gray "sections" button under the chosen topic. The Blog Writer will leverage OpenAI's GPT-4 model to generate section ideas that expand on the topic, helping you create a comprehensive blog post.
As shown in the image below, clicking on the gray "sections" button under the topic "Introduction: The Vision Behind DeepLearning.AI's Community Initiatives" will generate several content-rich sections for you to explore:
Choosing a Section for our selected Topic
After GPT-4o generates sections based on your topic, you can further structure your blog by selecting the section of your choice. To do this, simply click the <<< button next to the section you want to use. This section will then appear in the Design panel under the previously selected topic, allowing you to start writing content. 
As shown in the image below, clicking on the <<< button next to "Introduction: The Vision Behind DeepLearning.AI's Community Initiatives" will move that section into the Design panel:

Viewing Your Blog in the Preview Panel
Once you are done structuring  generated sections of your blog post, it's time to see how it will look before finalizing. You can do this by clicking the Preview link located at the top of the Design panel. This action opens the Preview Panel, displaying the complete blog post as it would appear to readers.
As shown in the image below, after clicking the Preview link, the full blog is rendered on the right-hand side of the window:
Conclusion
Building a blog can be a daunting task, but with the help of the Blog Writer tool, the process becomes smooth, structured, and efficient. From generating titles, topics, and sections to previewing the final blog, this tool takes the heavy lifting out of content creation. By leveraging powerful AI models like GPT-4, you can quickly brainstorm, refine, and create comprehensive blog posts with ease.
Happy blogging!